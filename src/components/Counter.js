// ============================================================
// IMPORTS
// ============================================================

// useSelector - a hook that lets this component READ data from the redux store
// it takes a callback function that receives the entire store as "state"
// and returns only the piece of data this component needs
// whenever that piece of data changes, the component automatically re-renders

// useDispatch - a hook that returns the dispatch function from the redux store
// dispatch is the ONLY way to send actions to the store and trigger state changes
// you cannot change the store directly - everything must go through dispatch
import { useSelector, useDispatch } from 'react-redux'

// increment        - action creator that returns { type: 'counter/increment' }
//                    when dispatched, the reducer runs: state.count += 1
// decrement        - action creator that returns { type: 'counter/decrement' }
//                    when dispatched, the reducer runs: state.count -= 1
// incrementByAmount - action creator that accepts a number as an argument
//                    returns { type: 'counter/incrementByAmount', payload: 20 }
//                    when dispatched, the reducer runs: state.count += action.payload
// all three were auto generated by createSlice inside counterSlice.js
import { increment, decrement, incrementByAmount } from '../redux/counterSlice'

// useGetAllPostsQuery  - auto generated hook by RTK Query for the getAllPosts endpoint
//                        when called, it fetches ALL posts from .../posts
//                        returns { data, isLoading, isError }
//                        no arguments needed because it fetches everything

// useGetPostByIdQuery  - auto generated hook by RTK Query for the getPostById endpoint
//                        when called with an id, it fetches ONE post from .../posts/5
//                        returns { data, isLoading, isError }
//                        requires an id argument to know which post to fetch
import { useGetAllPostsQuery, useGetPostByIdQuery } from '../redux/postsSlice';

// ============================================================
// COMPONENT
// ============================================================

export default function Counter() {

  // ============================================================
  // useSelector - READ state from the Redux store
  // ============================================================
  // useSelector takes a callback function as its argument
  // the callback receives "state" which is the ENTIRE Redux store (all slices)
  // we drill down using dot notation to get exactly what we need:
  //
  // state                = the entire redux store (all slices combined)
  // state.counter        = the counter slice (named "counter" in store.js)
  // state.counter.count  = the count number inside counterSlice's initialState
  //
  // useSelector also SUBSCRIBES this component to that piece of state
  // meaning whenever state.counter.count changes in the store,
  // React will automatically re-render this component with the latest value
  // we never have to manually update the UI ourselves
  const count = useSelector(state => state.counter.count)

  // ============================================================
  // useDispatch - SEND actions to the Redux store
  // ============================================================
  // useDispatch is a hook that connects this component to the Redux store's
  // dispatch function. We call it once and store it in a variable called dispatch
  // dispatch is the messenger - it takes an action object and sends it to the store
  // the store then finds the matching reducer and runs it to update the state
  // you CANNOT change Redux state directly - dispatch is the only way in
  const dispatch = useDispatch()

  // ============================================================
  // useGetAllPostsQuery - FETCH ALL posts from the API (commented out)
  // ============================================================
  // this hook was auto generated by RTK Query from the getAllPosts endpoint
  // calling it fires a GET request to: https://jsonplaceholder.typicode.com/posts
  // it returns an object with:
  //   data      = array of all post objects returned from the API
  //   isLoading = true while the request is still waiting for a response
  //   isError   = true if the request failed for any reason
  // it is commented out here because we are using useGetPostByIdQuery instead
  // const {data, isLoading, isError} = useGetAllPostsQuery()

  // ============================================================
  // useGetPostByIdQuery - FETCH a single post from the API
  // ============================================================
  // this hook was auto generated by RTK Query from the getPostById endpoint
  // calling it with the argument 5 fires a GET request to:
  // https://jsonplaceholder.typicode.com/posts/5
  // the 5 is passed as the "id" argument inside postsSlice query: (id) => `posts/${id}`
  // it returns an object with:
  //   data      = a single post object { id, title, body, userId } from the API
  //   isLoading = true while the request is still in progress
  //   isError   = true if something went wrong e.g. network error or bad id
  // RTK Query also handles caching automatically - if you call this hook again
  // with the same id, it will return the cached result instead of re-fetching
  const {data, isLoading, isError} = useGetPostByIdQuery(5)

  // ============================================================
  // JSX / TEMPLATE
  // ============================================================
  return (
    <div>

      {/* JSON.stringify(data) converts the post object from the API into a
          readable string so we can see the raw response on screen
          e.g. {"userId":1,"id":5,"title":"...","body":"..."}
          this updates automatically once the fetch completes and data is populated
          before the fetch completes, data is undefined so nothing shows */}
      {JSON.stringify(data)}

      {/* count comes from the Redux store via useSelector above
          it will automatically update every time the store changes
          both Counter.js and Counter2.js share this same count value
          because they both read from the same Redux store */}
      <h1>Count is {count}</h1>

      {/* ======================================================
          INCREMENT BUTTON
          ======================================================
          onClick fires an arrow function when the button is clicked
          the arrow function calls dispatch() with the increment() action creator
          increment() returns an action object: { type: 'counter/increment' }
          dispatch sends that action object to the Redux store
          the store finds the matching reducer (increment in counterSlice)
          the reducer runs: state.count += 1
          the store updates, useSelector detects the change, component re-renders
          the new count value appears on screen automatically */}
      <button onClick={() => dispatch(increment())}>Increment</button>

      {/* ======================================================
          DECREMENT BUTTON
          ======================================================
          onClick fires an arrow function when the button is clicked
          the arrow function calls dispatch() with the decrement() action creator
          decrement() returns an action object: { type: 'counter/decrement' }
          dispatch sends that action object to the Redux store
          the store finds the matching reducer (decrement in counterSlice)
          the reducer runs: state.count -= 1
          the store updates, useSelector detects the change, component re-renders
          the new count value appears on screen automatically */}
      <button onClick={() => dispatch(decrement())}>Decrement</button>

      {/* ======================================================
          INCREMENT BY AMOUNT BUTTON
          ======================================================
          onClick fires an arrow function when the button is clicked
          the arrow function calls dispatch() with incrementByAmount(20)
          the number 20 is passed as the argument and becomes action.payload
          incrementByAmount(20) returns:
          { type: 'counter/incrementByAmount', payload: 20 }
          dispatch sends that action object to the Redux store
          the store finds the matching reducer (incrementByAmount in counterSlice)
          the reducer runs: state.count += action.payload (which is 20)
          the store updates, useSelector detects the change, component re-renders
          the button label says "Add 5" but actually adds 20 - these should match */}
      <button onClick={() => dispatch(incrementByAmount(20))}>Add 5</button>

    </div>
  )
}